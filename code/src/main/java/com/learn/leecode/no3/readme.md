### 3. 无重复字符的最长子串

给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

### 示例 1:

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

### 示例 2:

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

### 示例 3:


```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

### 示例 4:


```
输入: s = ""
输出: 0
```

 

### 提示：

- 0 <= s.length <= 5 * 104
- s 由英文字母、数字、符号和空格组成


### 解题思路
字符串分为2个区，前半区是未重复的子字符串区，后半区是还未检查的区，设置头尾指针，初始化头尾指针相等都指向字符串第1个字符。循环字符串每一个字符，尾部指针向后移动，每循环一个字符，在已循环过的字符串前半区中查找是否存在该字符，如果不存在，则说明已循环过的字符串是无重复的子字符串。如果存在，说过该字符重复，计算前半区无重复的子字符串长度，与上次比较保留最大值，头指针指向已存在字符的下一个字符，继续循环。循环结束后，得出最大长度。

那么，在循环每一个字符时，如何查找已循环过的字符中是否存在当前字符串，关键就是记录下每一个字符串是否重复以及重复前的下标。
- 最容易想到的就是利用Map来记录，字符串长度很大的情况下，虽然Map时间复杂度为O(1),但存储和查找需要计算，存储空间需要动态扩展，会有性能损耗。
- 题目中说明字符由英文字母、数字、符号和空格组，可以利用字符的ASCII码作为数字下标，使用128长度的数组来记录字符的重复状态和重复前的下标。数组的存储和访问时间复杂度O(1)，性能更好。


> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。